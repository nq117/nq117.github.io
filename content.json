{"meta":{"title":"ltnq","subtitle":"做好现在的事！","description":"喝水不忘挖井人！","author":"ltnq","url":"https://nq117.github.io"},"pages":[{"title":"categories","date":"2017-12-19T02:36:51.000Z","updated":"2017-12-19T03:29:50.875Z","comments":true,"path":"categories/index.html","permalink":"https://nq117.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2017-12-19T02:40:12.000Z","updated":"2017-12-19T02:40:12.944Z","comments":true,"path":"about/index.html","permalink":"https://nq117.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-19T06:29:00.000Z","updated":"2017-12-19T06:46:13.282Z","comments":true,"path":"tags/index.html","permalink":"https://nq117.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo + github  轻松搭建个人主页","slug":"hexo-github-轻松搭建个人主页","date":"2017-12-18T06:46:09.000Z","updated":"2017-12-19T06:45:10.862Z","comments":true,"path":"2017/12/18/hexo-github-轻松搭建个人主页/","link":"","permalink":"https://nq117.github.io/2017/12/18/hexo-github-轻松搭建个人主页/","excerpt":"http://blog.csdn.net/qq_28844947 synchronize() 同步代码块同步函数所使用的锁就是this锁static所使用的锁就是该类的字节码文件对象 类名.class//懒汉式：延迟加载方式。当多线程访问懒汉式时，因为懒汉式的方法内对共性数据进行多条语句的操作。所以容易出现线程安全问题。为了解决，加入同步机制，解决安全问题。但是却带来了效率降低。为了效率问题，通过双重判断的形式解决。class Single{ private static Single s = null; private Single(){} public static Single getInstance(){ //锁是谁？字节码文件对象； if(s == null){ synchronized(Single.class){ if(s == null) s = new Single(); } } return s; }} Android 中 的 异 步 消 息 处 理 主 要 由 四 个 部 分 组 成 ， Message 、 Handler 、 MessageQueue 和 Looper。 Message ：Message 是在线程之间传递的消息 arg1 和 arg2 字段来携带一些整型数据，使用 obj 字段携带一个 Object 对象 Handler Handler 顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用 Handler 的 sendMessage()方法后，最终会传递到 Handler 的 handleMessage()方法中。 private Handler handler=new Handler(){ public void handleMessage(Message msg){ switch (msg.what){ case UPDATE_TEXT: //这里就可以从msg取出你从线程中传到UI线程的东西； //String aa=msg.obj.toString(); String aa= (String) msg.obj; txt.setText(aa); break; default: break; } } }; public void onClick(View view) { switch (view.getId()){ case R.id.btn: new Thread(new Runnable() { @Override public void run() { String aa=editText.getText().toString(); Log.d(“———-“,aa); //下面new一个Message用来装你要传到UI线程的东西 Message message =new Message(); message.what=UPDATE_TEXT; message.obj=aa; //msg.arg1 = ; handler.sendMessage(message); } }).start(); break; default: break; } }","text":"http://blog.csdn.net/qq_28844947 synchronize() 同步代码块同步函数所使用的锁就是this锁static所使用的锁就是该类的字节码文件对象 类名.class//懒汉式：延迟加载方式。当多线程访问懒汉式时，因为懒汉式的方法内对共性数据进行多条语句的操作。所以容易出现线程安全问题。为了解决，加入同步机制，解决安全问题。但是却带来了效率降低。为了效率问题，通过双重判断的形式解决。class Single{ private static Single s = null; private Single(){} public static Single getInstance(){ //锁是谁？字节码文件对象； if(s == null){ synchronized(Single.class){ if(s == null) s = new Single(); } } return s; }} Android 中 的 异 步 消 息 处 理 主 要 由 四 个 部 分 组 成 ， Message 、 Handler 、 MessageQueue 和 Looper。 Message ：Message 是在线程之间传递的消息 arg1 和 arg2 字段来携带一些整型数据，使用 obj 字段携带一个 Object 对象 Handler Handler 顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用 Handler 的 sendMessage()方法后，最终会传递到 Handler 的 handleMessage()方法中。 private Handler handler=new Handler(){ public void handleMessage(Message msg){ switch (msg.what){ case UPDATE_TEXT: //这里就可以从msg取出你从线程中传到UI线程的东西； //String aa=msg.obj.toString(); String aa= (String) msg.obj; txt.setText(aa); break; default: break; } } }; public void onClick(View view) { switch (view.getId()){ case R.id.btn: new Thread(new Runnable() { @Override public void run() { String aa=editText.getText().toString(); Log.d(“———-“,aa); //下面new一个Message用来装你要传到UI线程的东西 Message message =new Message(); message.what=UPDATE_TEXT; message.obj=aa; //msg.arg1 = ; handler.sendMessage(message); } }).start(); break; default: break; } } MessageQueue MessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的 消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个 MessageQueue 对象。 Looper Looper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop()方法后， 就会进入到一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会 将它取出，并传递到 Handler 的 handleMessage()方法中。每个线程中也只会有一个 Looper 对象。 AsyncTask AsyncTask是一个抽象类 指定三个泛型参数1.Params 在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。2.Progress 后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。3.Result 当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。 class DownloadTask extends AsyncTask { …… } AsyncTask 的第一个泛型参数指定为 Void，表示在执行 AsyncTask 的 时候不需要传入参数给后台任务。第二个泛型参数指定为 Integer，表示使用整型数据来作 为进度显示单位。第三个泛型参数指定为 Boolean，则表示使用布尔型数据来反馈执行结 果。 重写 AsyncTask 中的几个方法才能完成对任务的定制 onPreExecute()这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。 doInBackground(Params…) 这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask的第三个泛型参数指定的是 Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress…)方法来完成。 onProgressUpdate(Progress…) 当在后台任务中调用了 publishProgress(Progress…)方法后，这个方法就会很快被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应地更新。 onPostExecute(Result)当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。 一个比较完整的自定义 AsyncTask 就可以写成如下方式： class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; { @Override protected void onPreExecute() { progressDialog.show(); // 显示进度对话框 } @Override protected Boolean doInBackground(Void... params) { try { while (true) { int downloadPercent = doDownload(); // 这是一个虚构的方法 publishProgress(downloadPercent); if (downloadPercent &gt;= 100) { break; } } } catch (Exception e) { return false; } return true; } @Override protected void onProgressUpdate(Integer... values) { // 在这里更新下载进度 progressDialog.setMessage(&quot;Downloaded &quot; + values[0] + &quot;%&quot;); } @Override protected void onPostExecute(Boolean result) { progressDialog.dismiss(); // 关闭进度对话框 // 在这里提示下载结果 if (result) { Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(context, &quot; Download failed&quot;, Toast.LENGTH_SHORT).show(); } } }","categories":[{"name":"教程","slug":"教程","permalink":"https://nq117.github.io/categories/教程/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://nq117.github.io/tags/标签1/"},{"name":"标签2","slug":"标签2","permalink":"https://nq117.github.io/tags/标签2/"}]},{"title":"hello","slug":"hello","date":"2017-12-18T05:42:15.000Z","updated":"2017-12-18T05:42:15.468Z","comments":true,"path":"2017/12/18/hello/","link":"","permalink":"https://nq117.github.io/2017/12/18/hello/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-12-18T05:27:20.983Z","updated":"2017-12-19T06:31:55.079Z","comments":true,"path":"2017/12/18/hello-world/","link":"","permalink":"https://nq117.github.io/2017/12/18/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hello","slug":"hello","permalink":"https://nq117.github.io/tags/hello/"}]}]}